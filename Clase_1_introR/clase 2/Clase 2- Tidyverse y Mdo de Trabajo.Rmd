---
title: "Clase 2. Tidyverse y Mercado de Trabajo"
author: "Guido Weksler y Diego Kozlowski"
date: "13 de Octubre de 2017"
output: 
  html_notebook: 
    toc: true
    toc_float: true
    depth: 3

---

```{r, warning=FALSE}
rm(list=ls())
```

# [Tidyverse](https://www.tidyverse.org/)         

Este paquete agrupa una serie de paquetes que tienen una misma lógica en su diseño y por ende funcionan en armonía.     
Entre ellos usaremos principalmente __ggplot__ para realizar gráficos, y __dplyr__ y __tidyr__ para realizar transformaciones sobre nuestro set de datos.

A continuación cargamos la librería a nuestro ambiente. Para ello debe estar previamente instalada en nuestra pc.
```{r}
library(tidyverse)
```

Para mostrar el funcionamiento básico de tydyverse retomaremos el ejemplo de la clase 1, con lo cual volvemos a crear el set de datos del [Indice de salarios](http://www.indec.gob.ar/bajarCuadroEstadistico.asp?idc=4020B33440609462654542BD0BC320F1523DA0DC52C396201DB4DD5861FFEDC9AD1436681AC84179).
```{r}
INDICE  <- c(100,   100,   100,
             101.8, 101.2, 100.73,
             102.9, 102.4, 103.2)

FECHA  <-  c("Oct-16", "Oct-16", "Oct-16",
             "Nov-16", "Nov-16", "Nov-16",
             "Dic-16", "Dic-16", "Dic-16")


GRUPO  <-  c("Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado")

Datos <- data.frame(INDICE, FECHA, GRUPO)


```


## Dplyr

El caracter principal para utilizar este paquete es ```%>%``` , _pipe_ (de tubería).

Los ```%>%``` toman el set de datos a su izquierda, y los transforman mediante los comandos a su derecha, en los cuales los elementos de la izquierda están implícitos. En otros términos.

$f(x,y)$ es equivalente a $x$ %>% $f(.,y)$ 

Veamos las principales funciones que pueden utilizarse con la lógica de este paquete:

### filter

Permite filtrar la tabla acorde al cumplimiento de condiciones lógicas
 
```{r}
Datos %>% 
  filter(INDICE>101 , GRUPO == "Privado_Registrado")

```
Nótese que en este caso al separar con una  ```,``` las condiciones se exige el cumplimiento de ambas. En caso de desear que se cumpla una sola condición debe utilizarse el caracter ```|```
```{r}
Datos %>% 
  filter(INDICE>101 | GRUPO == "Privado_Registrado")
```

### rename
Permite renombrar una columna de la tabla. Funciona de la siguiente manera: 
 ```Data %>% rename( nuevo_nombre = viejo_nombre )``` 
```{r}
Datos %>% 
  rename(Periodo = FECHA)
```
Nótese que a diferencia del ejemplo de la función __filter__ donde utilizábamos __==__ para comprobar una condición lógica, en este caso se utiliza sólo un __=__ ya que lo estamos haciendo es _asignar_ un nombre.

### mutate
Permite agregar una variable a la tabla (especificando el nombre que tomará esta), que puede ser el resultado de operaciones sobre otras variables de la misma tabla.       

En caso de especificar el nombre de una columna existente, el resultado de la operación realizada "sobrescribirá" la información de la columna con dicho nombre
```{r}
Datos <- Datos %>% 
  mutate(Doble=INDICE*2)
Datos
```

### case_when
Permite definir una variable, la cual toma un valor particular para cada condición establecida. En caso de no cumplir ninguna de las condiciones establecidas la variable tomara valor __NA__
La sintaxis de la función es case_when( _condicion lógica1_ __~__ _valor asignado1_).

```{r}
Datos <- Datos %>% 
  mutate(Caso_cuando = case_when(GRUPO == "Privado_Registrado"   ~ INDICE*2,
                                 GRUPO == "Público"              ~ INDICE*3,
                                 GRUPO == "Privado_No_Registrado"~ INDICE*5))
Datos
```

### select
Permite especificar la serie de columnas que se desea conservar de un DataFrame. También pueden especificarse las columnas que se desean descartar (agregándoles un _-_). Muy útil para agilizar el trabajo en bases de datos de gran tamaño.
```{r}
Datos2 <- Datos %>% 
  select(INDICE, FECHA, GRUPO)
Datos2

Datos <- Datos %>% 
  select(-c(Doble,Caso_cuando))
Datos
```

### arrange
Permite ordenar la tabla por los valores de determinada/s variable/s. Es útil cuando luego deben hacerse otras operaciones que requieran del ordenamiento de la tabla
```{r}
Datos <- Datos %>% 
  arrange(GRUPO, INDICE)
Datos
```

### summarise
Crea una nueva tabla que resuma la información original. Para ello, definimos las variables de resumen y las formas de agregación.
```{r}
Datos %>% 
  summarise(Indprom = mean(INDICE))

```

### group_by
Esta función permite realizar operaciones de forma agrupada. Lo que hace la función es "separar" a la tabla según los valores de la variable indicada y realizar las operaciones que se especificaba  continuación, de manera independiente para cada una de las "subtablas". En nuestro ejemplo, sería útil para calcular el promedio de los indices por _Fecha_ 
```{r}
Datos %>% 
  group_by(FECHA) %>%
  summarise(Indprom = mean(INDICE))
```

## Joins

Otra implementación muy importante del paquete dplyr son las funciones para unir tablas (joins)


![fuente: http://rstudio-pubs-static.s3.amazonaws.com/227171_618ebdce0b9d44f3af65700e833593db.html](joins.png)         

###left_join    

Veamos un ejemplo de la función __left_join__ (una de las más utilizadas en la práctica).       
Para ello crearemos previamente un Dataframe que contenga un Ponderador para cada uno de los Grupos del Dataframe _Datos_. Aprovecharemos el ejemplo para introducir la función __weigthed.mean__, y así calcular un Indice Ponderado.

```{r}
Ponderadores <- data.frame(GRUPO = c("Privado_Registrado","Público","Privado_No_Registrado"),
                            PONDERADOR = c(50.16,29.91,19.93))

Datos_join <- Datos %>% 
  left_join(.,Ponderadores, by = "GRUPO")
Datos_join

Datos_Indice_Gral <- Datos_join %>% 
  group_by(FECHA) %>% 
  summarise(Indice_Gral = weighted.mean(INDICE,w = PONDERADOR))

Datos_Indice_Gral
```

## Tidyr

El paquete tidyr esta pensado para facilitar el emprolijamiento de los datos.

__Gather__ es una función que nos permite pasar los datos de forma horizontal a una forma vertical. 

__spread__ es una función que nos permite pasar los datos de forma vertical a una forma horizontal.

![fuente: http://www.gis-blog.com/data-management-with-r-tidyr-part-1/](spreadVSgather.png)


```{r}
#Utilzamos un conjunto de datos que viene con la librería datasets
library(datasets)

data(iris)
iris <- iris %>% 
  mutate(id = 1:nrow(.)) %>%  #le agrego un ID
  select(id, everything()) # lo acomodo para que el id este primero. 

iris
```


  
### Gather y Spread

```{r}
iris_vertical <- iris %>% gather(., # el . llama a lo que esta atras del %>% 
                                 key   = Variables,
                                 value = Valores,
                                 2:5) #le indico que columnas juntar
iris_vertical
```

Podemos deshacer el __gather__ con un __Spread__
```{r}
iris_horizontal <- iris_vertical %>%
  spread(. ,
         key   = Variables, #la llave es la variable que va a dar los nombres de columna
         value = Valores) #los valores con que se llenan las celdas
iris_horizontal
```


# [Mercado de Trabajo](http://www.indec.gob.ar/uploads/informesdeprensa/EPH_cont_1trim17.pdf)
Cuadros 1.1 y 1.2.


Cargamos dos librerías que usaremos respectivamente para leer y escribir archivos en excel.   

```{r, message=FALSE, warning=F}
library(readxl) # para leer archivos en excel
library(xlsx)   # para escribir archivos en excel
```

#### Carpetas de Trabajo

Dado que vamos a trabajar utilizando información almacenada en el disco, resultará útil crear objetos que contengan las direcciones de nuestras carpetas de trabajo.
A continuación veremos una formula genérica de crear estos objetos, a partir de identificar donde esta guardado el script.
```{r}
# Funcion para obtener la direccion del Script Obtengo la ubicación del Script en el Disco
dir <- paste0(dirname(rstudioapi::getActiveDocumentContext()$path),"/")

# A partir del objeto dir, creo un objeto con la dirección de la carpeta que contiene los microdatos y otro con la que contendrá los resultados.

bases.dir      <-  paste0(dirname(dir),"/Fuentes/")
resultados.dir <- paste0(dirname(dir),"/Resultados/")
```

#### Carga de Informacion

La función __list.files__ nos permite observar los archivos que contiene una determinada carpeta             

```{r}
list.files(bases.dir)
```
La función __read.table__ nos permite levantar los archivos de extensión ".txt"               
La función __read_excel__ nos permite levantar los archivos de extensión ".xlsx"                 

Levantamos la base individual del primer trimestre de 2017, y un listado que contiene los Nombres y Códigos de los Aglomerados EPH.
```{r}
Individual_t117 <-
  read.table(
  paste0(bases.dir, "usu_individual_t117.txt"),
  sep = ";",
  dec = ",",
  header = TRUE,
  fill = TRUE )
  
  
  Aglom <- read_excel(paste0(bases.dir, "Aglomerados EPH.xlsx"))
```



## Cuadro 1.1 

Creo una tabla con los niveles de:
- Población
- Ocupados
- Desocupados
- PEA
- Ocupados demandantes
- Subocupados (demandantes, no demandantes y total)

Estos niveles nos van a permitir calcular las tasas de forma sencilla. 

```{r}
####Cuadro 1.1 Principales indicadores. Total 31 aglomerados u

Cuadro_1.1a <- Individual_t117 %>% 
  summarise(Poblacion         = sum(PONDERA),
            Ocupados          = sum(PONDERA[ESTADO == 1]),
            Desocupados       = sum(PONDERA[ESTADO == 2]),
            PEA               = Ocupados + Desocupados,
            Ocupados_demand   = sum(PONDERA[ESTADO == 1 & PP03J ==1]),
            Suboc_demandante  = sum(PONDERA[ESTADO == 1 & INTENSI ==1 & PP03J==1]),
            Suboc_no_demand   = sum(PONDERA[ESTADO == 1 & INTENSI ==1 & PP03J %in% c(2,9)]),
            Subocupados       = Suboc_demandante + Suboc_no_demand ,
# También podemos llamar a las variables entre comillas, incluyendo nombres compuestos
# A su vez, podemos utilizar la variable recién creada en la definción de otra varible
            'Tasa Actividad'                  = PEA/Poblacion,
            'Tasa Empleo'                     = Ocupados/Poblacion,
            'Tasa Desocupacion'               = Desocupados/PEA,
            'Tasa ocupados demandantes'       = Ocupados_demand/PEA,
            'Tasa Subocupación'               = Subocupados/PEA,
            'Tasa Subocupación demandante'    = Suboc_demandante/PEA,
            'Tasa Subocupación no demandante' = Suboc_no_demand/PEA) 
Cuadro_1.1a 
```

Una vez que calculamos las tasas, podemos borrar los niveles con un __select__
```{r}
Cuadro_1.1a <- Cuadro_1.1a %>% 
  select(-c(1:8))

Cuadro_1.1a
```

Con __gather__ podemos dar vuelta la tabla para que quede como en la publicación

```{r}

Cuadro_1.1a <- Cuadro_1.1a %>% 
  gather(Tasas, Valor, 1:ncol(.))


Cuadro_1.1a
```

En caso de querer expresar los resultados como porcentajes, utilizamos la función __sprintf__. Para ello debemos utilizar __mutate__ para transformar la columna Valor.
```{r}
Cuadro_1.1a <- Cuadro_1.1a %>% 
  mutate(Valor = sprintf("%1.1f%%", 100*Valor))

Cuadro_1.1a
```
Nótese que en este caso, para poder añadir el %, la función transforma a la variable en un Character, por ende debe tenerse en cuenta que se pierde la información del numero completo.

## Cuadro 1.2

En este caso, podemos ver que simplemente agregando la función __group_by__ podemos replicar el procedimiento para cada uno de los aglomerados. Y a su vez, podemos realizar en un solo paso los arreglos posteriores sobre nuestra tabla.

```{r}
Cuadro_1.2a <- Individual_t117 %>% 
  group_by(AGLOMERADO) %>% 
  summarise(Poblacion         = sum(PONDERA),
            Ocupados          = sum(PONDERA[ESTADO == 1]),
            Desocupados       = sum(PONDERA[ESTADO == 2]),
            PEA               = Ocupados + Desocupados,
            Ocupados_demand   = sum(PONDERA[ESTADO == 1 & PP03J == 1]),
            Suboc_demandante  = sum(PONDERA[ESTADO == 1 & INTENSI == 1 & PP03J == 1]),
            Suboc_no_demand   = sum(PONDERA[ESTADO == 1 & INTENSI == 1 & PP03J %in% c(2, 9)]),
            Subocupados       = Suboc_demandante + Suboc_no_demand,
            'Tasa Actividad'                  = PEA/Poblacion,
            'Tasa Empleo'                     = Ocupados/Poblacion,
            'Tasa Desocupacion'               = Desocupados/PEA,
            'Tasa ocupados demandantes'       = Ocupados_demand/PEA,
            'Tasa Subocupación'               = Subocupados/PEA,
            'Tasa Subocupación demandante'    = Suboc_demandante/PEA,
            'Tasa Subocupación no demandante' = Suboc_no_demand/PEA) %>% 
  select(-c(2:9)) %>% 
  left_join(.,Aglom) %>% 
  select(Nom_Aglo,everything(.),-AGLOMERADO) 

Cuadro_1.2a
```

#### Exportar resultados a  Excel
La función __write.xlsx__ nos permite guardar en un Excel los resultados de nuestro procesamiento de la información. Esta función requiere que el tipo de Datos sea un DataFrame.
```{r}
class(Cuadro_1.2a)
```
Como nos muestra la función __class__, la funciones del  __tidyverse__ al realizar las operaciones agrupadas, transforma el tipo de de los datos. Por ende, para guardar los resultados debemos reconvertir nuestra tabla en un DataFrame con la función __as.data.frame__.    

__write.xlsx__ entre sus parámetros requiere especificar:

- El objeto a guardar
- La ruta y nombre del archivo que será guardado

De manera opcional puede también especificarse:

- El nombre de la Hoja
- Si se desea pisar (append = FALSE) o incorporar (append = TRUE) archivos que tengan el mismo nombre
- Si deseamos que figuren o no los números de filas en nuestra tabla           

```{r eval=FALSE}
write.xlsx(as.data.frame(Cuadro_1.1a), paste0(resultados.dir,"Informe Mercado de Trabajo.xlsx"),sheetName = "Cuadro 1.1", append = FALSE, row.names = FALSE)

write.xlsx(as.data.frame(Cuadro_1.2a), paste0(resultados.dir,"Informe Mercado de Trabajo.xlsx"),sheetName = "Cuadro 1.2", append = TRUE, row.names = FALSE)

```


# Ejercicios para practicar

- Levantar la última base individual de EPH
- Crear un vector llamado __Variables__ que contenga los nombres de las siguientes variables de interés para realizar algunos ejercicios:
      - Edad, Sexo, Ingreso de la ocupación principal, Categoría ocupacional, ESTADO, PONDERA y PONDIH
- Acotar la Base únicamente a las variables de interés, utilizando el vector __Variables__ 

- Calcular las tasas de actividad, empleo y desempleo según sexo, para jóvenes entre 18 y 35 años
- Calcular el salario promedio por sexo, para dos grupos de edad: 18 a 35 años y 36 a 70 años. (Recordatorio: La base debe filtrarse para contener únicamente OCUPADOS ASALARIADOS)
- Grabar los resultados en un excel (Previamente creando un objeto que contenga el directorio a utilizar)
- Replicar el cálculo de las tasas anteriores para distintos trimestres,levantando las bases desde el segundo trimestre 2016 hasta la última.
    - Tips: juntar las bases con el comando ```bind_rows()```
    - Probar con ```gather()``` y ```spread()``` como quedan mejor los resultados
